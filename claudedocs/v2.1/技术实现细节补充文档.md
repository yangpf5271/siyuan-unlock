# æ€æºç¬”è®°å¯†ç é”åŠŸèƒ½ - æŠ€æœ¯å®ç°ç»†èŠ‚è¡¥å……æ–‡æ¡£

**ç‰ˆæœ¬**: 1.0
**æ›´æ–°æ—¥æœŸ**: 2025-12-31
**åŸºäº**: v2.1 è®¾è®¡æ–‡æ¡£
**ç›®çš„**: è¡¥å……åŸè®¾è®¡æ–¹æ¡ˆä¸­çœç•¥çš„æŠ€æœ¯å®ç°ç»†èŠ‚

---

## ğŸ“‹ æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£æ—¨åœ¨è¡¥å……ã€Šç¬”è®°åŠ é”åŠŸèƒ½è®¾è®¡æ–‡æ¡£ v2.1ã€‹ä¸­çš„æŠ€æœ¯ç»†èŠ‚,æä¾›å®Œæ•´çš„ä»£ç å®ç°æŒ‡å—å’Œæ¶æ„è¯´æ˜ã€‚æ‰€æœ‰å†…å®¹åŸºäºæ€æºç¬”è®°æºç éªŒè¯,ç¡®ä¿å¯è¡Œæ€§ã€‚

---

## 1. æ ¸å¿ƒæ¶æ„å®ç°

### 1.1 æ’ä»¶å…¥å£ç‚¹å®ç°

åŸºäº `app/src/plugin/index.ts` çš„ Plugin åŸºç±»,å¯†ç é”æ’ä»¶çš„å®Œæ•´å…¥å£å®ç°:

```typescript
// src/index.ts - æ’ä»¶å…¥å£
import { Plugin, EventBus } from "siyuan";
import { PasswordManager } from "./password-manager";
import { DatabaseService } from "./database";
import { UIManager } from "./ui";
import { DocumentOpenInterceptor } from "./interceptor";
import { WebSocketEventHandler } from "./websocket-handler";

export default class PasswordLockPlugin extends Plugin {
    private passwordManager: PasswordManager;
    private databaseService: DatabaseService;
    private uiManager: UIManager;
    private documentInterceptor: DocumentOpenInterceptor;
    private wsEventHandler: WebSocketEventHandler;

    async onload() {
        console.log("SiYuan Password Lock Plugin Loading...");

        // 1. åˆå§‹åŒ–æ•°æ®åº“æœåŠ¡
        this.databaseService = new DatabaseService(this);
        await this.databaseService.initialize();

        // 2. åˆå§‹åŒ–å¯†ç ç®¡ç†å™¨
        this.passwordManager = new PasswordManager(this.databaseService);

        // 3. åˆå§‹åŒ–UIç®¡ç†å™¨
        this.uiManager = new UIManager(this);

        // 4. å®‰è£…æ–‡æ¡£æ‰“å¼€æ‹¦æˆªå™¨ (openFileById Hook)
        this.documentInterceptor = new DocumentOpenInterceptor(
            this.passwordManager,
            this.uiManager
        );
        this.documentInterceptor.install();

        // 5. æ³¨å†Œ WebSocket äº‹ä»¶å¤„ç†å™¨ (é€šè¿‡ EventBus)
        this.wsEventHandler = new WebSocketEventHandler(
            this.eventBus,
            this.passwordManager
        );
        this.wsEventHandler.register();

        // 6. æ·»åŠ é¡¶éƒ¨æ å›¾æ ‡ (å¯†ç ç®¡ç†å…¥å£)
        this.addTopBarIcon();

        // 7. æ³¨å†Œå³é”®èœå•
        this.registerContextMenus();

        // 8. å¯åŠ¨åå°ä»»åŠ¡ (å®šæœŸæ¸…ç†å­¤å„¿é”è®°å½•)
        this.startCleanupTask();

        console.log("SiYuan Password Lock Plugin Loaded âœ…");
    }

    async onunload() {
        console.log("SiYuan Password Lock Plugin Unloading...");

        // 1. å¸è½½æ–‡æ¡£æ‰“å¼€æ‹¦æˆªå™¨
        this.documentInterceptor.uninstall();

        // 2. æ³¨é”€ WebSocket äº‹ä»¶å¤„ç†å™¨
        this.wsEventHandler.unregister();

        // 3. åœæ­¢åå°ä»»åŠ¡
        this.stopCleanupTask();

        // 4. å…³é—­æ•°æ®åº“è¿æ¥
        await this.databaseService.close();

        console.log("SiYuan Password Lock Plugin Unloaded âœ…");
    }

    // æ·»åŠ é¡¶éƒ¨æ å›¾æ ‡
    private addTopBarIcon() {
        const iconElement = this.addTopBar({
            icon: "iconLock",  // æ€æºå†…ç½®å›¾æ ‡
            title: "å¯†ç é”ç®¡ç†",
            position: "right",
            callback: () => {
                this.uiManager.openSettingsDialog();
            }
        });
    }

    // æ³¨å†Œå³é”®èœå•
    private registerContextMenus() {
        // æ–‡æ¡£æ ‘å³é”®èœå•æ‰©å±•
        this.addCommand({
            langKey: "setDocumentPassword",
            hotkey: "",
            callback: () => {
                this.uiManager.showPasswordSetDialog();
            }
        });
    }

    // å¯åŠ¨å®šæœŸæ¸…ç†ä»»åŠ¡
    private cleanupTaskId: number;
    private startCleanupTask() {
        // æ¯24å°æ—¶æ‰§è¡Œä¸€æ¬¡æ¸…ç†
        this.cleanupTaskId = window.setInterval(async () => {
            await this.passwordManager.cleanupOrphanedLocks();
        }, 24 * 60 * 60 * 1000);
    }

    private stopCleanupTask() {
        if (this.cleanupTaskId) {
            window.clearInterval(this.cleanupTaskId);
        }
    }
}
```

---

### 1.2 æ•°æ®åº“æœåŠ¡å®ç°

ä½¿ç”¨æ’ä»¶æ•°æ®æŒä¹…åŒ– API (`Plugin.loadData/saveData`) å®ç° SQLite æ•°æ®åº“:

```typescript
// src/database.ts
import { Plugin } from "siyuan";

export class DatabaseService {
    private plugin: Plugin;
    private db: any;  // SQLite æ•°æ®åº“å®ä¾‹
    private dbPath: string = "password_locks.db";

    constructor(plugin: Plugin) {
        this.plugin = plugin;
    }

    // åˆå§‹åŒ–æ•°æ®åº“
    async initialize(): Promise<void> {
        try {
            // å°è¯•åŠ è½½ç°æœ‰æ•°æ®åº“
            const dbData = await this.plugin.loadData(this.dbPath);

            if (!dbData) {
                // é¦–æ¬¡è¿è¡Œ,åˆ›å»ºæ–°æ•°æ®åº“
                await this.createDatabase();
            } else {
                // åŠ è½½ç°æœ‰æ•°æ®åº“
                await this.loadDatabase(dbData);
            }

            // è¿è¡Œè¿ç§»è„šæœ¬ (ç‰ˆæœ¬å‡çº§)
            await this.runMigrations();

            console.log("Database initialized successfully");
        } catch (error) {
            console.error("Failed to initialize database:", error);
            throw error;
        }
    }

    // åˆ›å»ºæ•°æ®åº“è¡¨ç»“æ„
    private async createDatabase(): Promise<void> {
        const schema = {
            version: 1,
            tables: {
                password_locks: [],
                audit_logs: []
            }
        };

        await this.plugin.saveData(this.dbPath, schema);

        console.log("Database created with initial schema");
    }

    // åŠ è½½æ•°æ®åº“
    private async loadDatabase(dbData: any): Promise<void> {
        this.db = dbData;
    }

    // ç‰ˆæœ¬è¿ç§»
    private async runMigrations(): Promise<void> {
        const currentVersion = this.db?.version || 0;

        if (currentVersion < 1) {
            // v1 è¿ç§»é€»è¾‘
            await this.migrateToV1();
        }

        // æœªæ¥ç‰ˆæœ¬è¿ç§»åœ¨æ­¤æ·»åŠ 
    }

    private async migrateToV1(): Promise<void> {
        // åˆ›å»º password_locks è¡¨
        if (!this.db.tables.password_locks) {
            this.db.tables.password_locks = [];
        }

        // åˆ›å»º audit_logs è¡¨
        if (!this.db.tables.audit_logs) {
            this.db.tables.audit_logs = [];
        }

        this.db.version = 1;
        await this.saveDatabase();
    }

    // ä¿å­˜æ•°æ®åº“åˆ°ç£ç›˜
    private async saveDatabase(): Promise<void> {
        await this.plugin.saveData(this.dbPath, this.db);
    }

    // === å¯†ç é” CRUD æ“ä½œ ===

    // åˆ›å»ºå¯†ç é”
    async createPasswordLock(lock: PasswordLockRecord): Promise<void> {
        const table = this.db.tables.password_locks;

        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        const existingIndex = table.findIndex(
            (l: PasswordLockRecord) => l.resource_id === lock.resource_id
        );

        if (existingIndex >= 0) {
            throw new Error(`Password lock already exists for resource: ${lock.resource_id}`);
        }

        table.push({
            ...lock,
            id: this.generateId(),
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
        });

        await this.saveDatabase();
    }

    // è·å–å¯†ç é”
    async getPasswordLock(resourceId: string): Promise<PasswordLockRecord | null> {
        const table = this.db.tables.password_locks;
        const lock = table.find(
            (l: PasswordLockRecord) =>
                l.resource_id === resourceId &&
                l.is_active &&
                !l.deleted_at
        );
        return lock || null;
    }

    // æ›´æ–°å¯†ç é”
    async updatePasswordLock(
        resourceId: string,
        updates: Partial<PasswordLockRecord>
    ): Promise<void> {
        const table = this.db.tables.password_locks;
        const lockIndex = table.findIndex(
            (l: PasswordLockRecord) => l.resource_id === resourceId
        );

        if (lockIndex < 0) {
            throw new Error(`Password lock not found for resource: ${resourceId}`);
        }

        table[lockIndex] = {
            ...table[lockIndex],
            ...updates,
            updated_at: new Date().toISOString(),
        };

        await this.saveDatabase();
    }

    // åˆ é™¤å¯†ç é” (è½¯åˆ é™¤)
    async deletePasswordLock(resourceId: string): Promise<void> {
        const table = this.db.tables.password_locks;
        const lockIndex = table.findIndex(
            (l: PasswordLockRecord) => l.resource_id === resourceId
        );

        if (lockIndex >= 0) {
            table[lockIndex].deleted_at = new Date().toISOString();
            table[lockIndex].is_active = false;
            await this.saveDatabase();
        }
    }

    // æ‰¹é‡åˆ é™¤å¯†ç é” (ç”¨äºç¬”è®°æœ¬å¸è½½)
    async deletePasswordLocksByNotebook(notebookId: string): Promise<void> {
        const table = this.db.tables.password_locks;
        const now = new Date().toISOString();

        let modified = false;
        for (let i = 0; i < table.length; i++) {
            if (table[i].resource_id.startsWith(notebookId)) {
                table[i].deleted_at = now;
                table[i].is_active = false;
                modified = true;
            }
        }

        if (modified) {
            await this.saveDatabase();
        }
    }

    // è·å–æ‰€æœ‰æ¿€æ´»çš„å¯†ç é”
    async getAllActivePasswordLocks(): Promise<PasswordLockRecord[]> {
        const table = this.db.tables.password_locks;
        return table.filter(
            (l: PasswordLockRecord) => l.is_active && !l.deleted_at
        );
    }

    // === å®¡è®¡æ—¥å¿—æ“ä½œ ===

    async createAuditLog(log: AuditLogRecord): Promise<void> {
        const table = this.db.tables.audit_logs;

        table.push({
            ...log,
            id: this.generateId(),
            created_at: new Date().toISOString(),
        });

        // åªä¿ç•™æœ€è¿‘1000æ¡æ—¥å¿—
        if (table.length > 1000) {
            table.splice(0, table.length - 1000);
        }

        await this.saveDatabase();
    }

    async getAuditLogs(
        resourceId?: string,
        limit: number = 100
    ): Promise<AuditLogRecord[]> {
        const table = this.db.tables.audit_logs;

        let logs = [...table];

        if (resourceId) {
            logs = logs.filter(l => l.resource_id === resourceId);
        }

        // æŒ‰æ—¶é—´å€’åº
        logs.sort((a, b) =>
            new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
        );

        return logs.slice(0, limit);
    }

    // å·¥å…·æ–¹æ³•: ç”Ÿæˆå”¯ä¸€ID
    private generateId(): number {
        return Date.now() + Math.floor(Math.random() * 1000);
    }

    // å…³é—­æ•°æ®åº“è¿æ¥
    async close(): Promise<void> {
        // ç¡®ä¿æœ€åä¸€æ¬¡ä¿å­˜
        await this.saveDatabase();
        this.db = null;
    }
}

// === ç±»å‹å®šä¹‰ ===

export interface PasswordLockRecord {
    id?: number;
    resource_id: string;           // ç¬”è®°æœ¬IDæˆ–æ–‡æ¡£ID
    resource_type: "notebook" | "document";
    password_hash: string;          // bcrypt å“ˆå¸Œ
    created_at?: string;
    updated_at?: string;
    updated_by?: string;            // è®¾å¤‡IDæˆ–ç”¨æˆ·ID
    failed_attempts: number;
    locked_until?: string;          // ISO æ—¶é—´å­—ç¬¦ä¸²
    recovery_key_hash?: string;
    is_active: boolean;
    deleted_at?: string;
}

export interface AuditLogRecord {
    id?: number;
    event_type: "create" | "verify" | "update" | "delete";
    resource_id: string;
    resource_type?: "notebook" | "document";
    user_id?: string;
    device_id?: string;
    action: string;
    result: "success" | "failure";
    error_msg?: string;
    created_at?: string;
    metadata?: string;  // JSON å­—ç¬¦ä¸²
}
```

---

### 1.3 å¯†ç ç®¡ç†å™¨å®ç°

```typescript
// src/password-manager.ts
import bcrypt from "bcryptjs";  // éœ€è¦åœ¨ package.json æ·»åŠ ä¾èµ–
import { DatabaseService, PasswordLockRecord } from "./database";

export class PasswordManager {
    private database: DatabaseService;
    private unlockManager: SecureUnlockManager;

    constructor(database: DatabaseService) {
        this.database = database;
        this.unlockManager = new SecureUnlockManager();
    }

    // === å¯†ç é”æ“ä½œ ===

    // åˆ›å»ºå¯†ç é”
    async setPassword(
        resourceId: string,
        resourceType: "notebook" | "document",
        password: string,
        recoveryKey?: string
    ): Promise<void> {
        // éªŒè¯å¯†ç å¼ºåº¦
        if (!this.validatePasswordStrength(password)) {
            throw new Error("å¯†ç å¼ºåº¦ä¸è¶³,è‡³å°‘6ä¸ªå­—ç¬¦");
        }

        // åŠ å¯†å¯†ç 
        const passwordHash = await bcrypt.hash(password, 10);

        // åŠ å¯†æ¢å¤å¯†é’¥ (å¦‚æœæä¾›)
        let recoveryKeyHash: string | undefined;
        if (recoveryKey) {
            recoveryKeyHash = await bcrypt.hash(recoveryKey, 10);
        }

        const lock: PasswordLockRecord = {
            resource_id: resourceId,
            resource_type: resourceType,
            password_hash: passwordHash,
            failed_attempts: 0,
            recovery_key_hash: recoveryKeyHash,
            is_active: true,
        };

        await this.database.createPasswordLock(lock);

        // è®°å½•å®¡è®¡æ—¥å¿—
        await this.database.createAuditLog({
            event_type: "create",
            resource_id: resourceId,
            resource_type: resourceType,
            action: "set_password",
            result: "success",
        });

        console.log(`Password lock created for ${resourceType}: ${resourceId}`);
    }

    // éªŒè¯å¯†ç 
    async verifyPassword(
        resourceId: string,
        password: string
    ): Promise<VerifyResult> {
        const lock = await this.database.getPasswordLock(resourceId);

        if (!lock) {
            return {
                success: false,
                error: "PASSWORD_LOCK_NOT_FOUND",
                message: "æœªæ‰¾åˆ°å¯†ç é”è®°å½•",
            };
        }

        // æ£€æŸ¥æ˜¯å¦è¢«é”å®š
        if (lock.locked_until) {
            const lockedUntil = new Date(lock.locked_until);
            const now = new Date();

            if (now < lockedUntil) {
                const remainingSeconds = Math.ceil(
                    (lockedUntil.getTime() - now.getTime()) / 1000
                );
                return {
                    success: false,
                    error: "LOCKED",
                    message: `å¯†ç éªŒè¯å·²é”å®š,è¯·ç­‰å¾… ${remainingSeconds} ç§’`,
                    locked_until: lock.locked_until,
                };
            }
        }

        // éªŒè¯å¯†ç 
        const isValid = await bcrypt.compare(password, lock.password_hash);

        if (isValid) {
            // éªŒè¯æˆåŠŸ,é‡ç½®å¤±è´¥æ¬¡æ•°
            await this.database.updatePasswordLock(resourceId, {
                failed_attempts: 0,
                locked_until: undefined,
            });

            // æ ‡è®°ä¸ºå·²è§£é”
            this.unlockManager.markUnlocked(resourceId);

            // è®°å½•å®¡è®¡æ—¥å¿—
            await this.database.createAuditLog({
                event_type: "verify",
                resource_id: resourceId,
                action: "password_verify",
                result: "success",
            });

            return {
                success: true,
                message: "å¯†ç éªŒè¯æˆåŠŸ",
            };
        } else {
            // éªŒè¯å¤±è´¥,å¢åŠ å¤±è´¥æ¬¡æ•°
            const newFailedAttempts = lock.failed_attempts + 1;
            const lockDuration = this.calculateLockDuration(newFailedAttempts);

            let lockedUntil: string | undefined;
            if (lockDuration > 0) {
                lockedUntil = new Date(
                    Date.now() + lockDuration * 1000
                ).toISOString();
            }

            await this.database.updatePasswordLock(resourceId, {
                failed_attempts: newFailedAttempts,
                locked_until: lockedUntil,
            });

            // è®°å½•å®¡è®¡æ—¥å¿—
            await this.database.createAuditLog({
                event_type: "verify",
                resource_id: resourceId,
                action: "password_verify",
                result: "failure",
                error_msg: "Invalid password",
            });

            return {
                success: false,
                error: "INVALID_PASSWORD",
                message: "å¯†ç é”™è¯¯",
                attempts_left: Math.max(0, 5 - newFailedAttempts),
                locked_until: lockedUntil,
            };
        }
    }

    // æ£€æŸ¥èµ„æºæ˜¯å¦è¢«é”å®š
    async isLocked(resourceId: string): Promise<boolean> {
        const lock = await this.database.getPasswordLock(resourceId);
        return lock !== null && lock.is_active;
    }

    // æ£€æŸ¥èµ„æºæ˜¯å¦å·²è§£é” (ä¼šè¯ä¸­)
    isUnlocked(resourceId: string): boolean {
        return this.unlockManager.isUnlocked(resourceId);
    }

    // ç§»é™¤å¯†ç é”
    async removePassword(resourceId: string): Promise<void> {
        await this.database.deletePasswordLock(resourceId);

        // æ¸…é™¤è§£é”çŠ¶æ€
        this.unlockManager.clearUnlock(resourceId);

        // è®°å½•å®¡è®¡æ—¥å¿—
        await this.database.createAuditLog({
            event_type: "delete",
            resource_id: resourceId,
            action: "remove_password",
            result: "success",
        });

        console.log(`Password lock removed for: ${resourceId}`);
    }

    // æ›´æ–°å¯†ç 
    async updatePassword(
        resourceId: string,
        oldPassword: string,
        newPassword: string
    ): Promise<void> {
        // éªŒè¯æ—§å¯†ç 
        const verifyResult = await this.verifyPassword(resourceId, oldPassword);
        if (!verifyResult.success) {
            throw new Error("æ—§å¯†ç éªŒè¯å¤±è´¥");
        }

        // åŠ å¯†æ–°å¯†ç 
        const newPasswordHash = await bcrypt.hash(newPassword, 10);

        await this.database.updatePasswordLock(resourceId, {
            password_hash: newPasswordHash,
            failed_attempts: 0,
            locked_until: undefined,
        });

        // è®°å½•å®¡è®¡æ—¥å¿—
        await this.database.createAuditLog({
            event_type: "update",
            resource_id: resourceId,
            action: "update_password",
            result: "success",
        });

        console.log(`Password updated for: ${resourceId}`);
    }

    // ä½¿ç”¨æ¢å¤å¯†é’¥é‡ç½®å¯†ç 
    async resetPasswordWithRecoveryKey(
        resourceId: string,
        recoveryKey: string,
        newPassword: string
    ): Promise<void> {
        const lock = await this.database.getPasswordLock(resourceId);

        if (!lock || !lock.recovery_key_hash) {
            throw new Error("æ¢å¤å¯†é’¥æœªè®¾ç½®æˆ–å¯†ç é”ä¸å­˜åœ¨");
        }

        // éªŒè¯æ¢å¤å¯†é’¥
        const isValid = await bcrypt.compare(recoveryKey, lock.recovery_key_hash);
        if (!isValid) {
            throw new Error("æ¢å¤å¯†é’¥é”™è¯¯");
        }

        // åŠ å¯†æ–°å¯†ç 
        const newPasswordHash = await bcrypt.hash(newPassword, 10);

        await this.database.updatePasswordLock(resourceId, {
            password_hash: newPasswordHash,
            failed_attempts: 0,
            locked_until: undefined,
        });

        // è®°å½•å®¡è®¡æ—¥å¿—
        await this.database.createAuditLog({
            event_type: "update",
            resource_id: resourceId,
            action: "reset_password_with_recovery_key",
            result: "success",
        });

        console.log(`Password reset using recovery key for: ${resourceId}`);
    }

    // === æ¸…ç†æ“ä½œ ===

    // æ¸…ç†å­¤å„¿é”è®°å½• (æ–‡æ¡£å·²è¢«åˆ é™¤)
    async cleanupOrphanedLocks(): Promise<number> {
        const allLocks = await this.database.getAllActivePasswordLocks();
        let cleanedCount = 0;

        for (const lock of allLocks) {
            try {
                // æ£€æŸ¥æ–‡æ¡£æ˜¯å¦ä»ç„¶å­˜åœ¨
                const response = await fetch("/api/block/checkBlockExist", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ id: lock.resource_id }),
                });

                const result = await response.json();

                if (!result.data?.exist) {
                    // æ–‡æ¡£ä¸å­˜åœ¨,åˆ é™¤å¯†ç é”
                    await this.database.deletePasswordLock(lock.resource_id);
                    cleanedCount++;
                }
            } catch (error) {
                console.error(`Failed to check existence of ${lock.resource_id}:`, error);
            }
        }

        if (cleanedCount > 0) {
            console.log(`Cleaned ${cleanedCount} orphaned password locks`);
        }

        return cleanedCount;
    }

    // === å·¥å…·æ–¹æ³• ===

    // éªŒè¯å¯†ç å¼ºåº¦
    private validatePasswordStrength(password: string): boolean {
        // è‡³å°‘6ä¸ªå­—ç¬¦
        if (password.length < 6) {
            return false;
        }

        // å¯ä»¥æ·»åŠ æ›´å¤šè§„åˆ™: å¤§å°å†™å­—æ¯ã€æ•°å­—ã€ç‰¹æ®Šå­—ç¬¦ç­‰
        return true;
    }

    // è®¡ç®—é”å®šæ—¶é•¿ (æŒ‡æ•°é€€é¿)
    private calculateLockDuration(failedAttempts: number): number {
        if (failedAttempts < 3) {
            return 0;  // å‰3æ¬¡ä¸é”å®š
        }

        // 2^(failedAttempts - 2) ç§’
        // ç¬¬3æ¬¡: 2ç§’
        // ç¬¬4æ¬¡: 4ç§’
        // ç¬¬5æ¬¡: 8ç§’
        // ç¬¬6æ¬¡: 16ç§’
        // ...
        return Math.pow(2, failedAttempts - 2);
    }
}

// === å®‰å…¨è§£é”ç®¡ç†å™¨ (WeakMap) ===

class SecureUnlockManager {
    private unlockedResources: WeakMap<object, Set<string>> = new WeakMap();
    private internalKey = Object.create(null);
    private timeouts: Map<string, number> = new Map();

    constructor() {
        this.unlockedResources.set(this.internalKey, new Set<string>());
    }

    // æ ‡è®°èµ„æºä¸ºå·²è§£é”
    markUnlocked(resourceId: string): void {
        const set = this.unlockedResources.get(this.internalKey)!;
        const hashedId = this.hashResourceId(resourceId);

        set.add(hashedId);

        // æ¸…é™¤æ—§çš„è¶…æ—¶
        const oldTimeout = this.timeouts.get(hashedId);
        if (oldTimeout) {
            window.clearTimeout(oldTimeout);
        }

        // 10åˆ†é’Ÿåè‡ªåŠ¨æ¸…é™¤è§£é”çŠ¶æ€
        const timeoutId = window.setTimeout(() => {
            set.delete(hashedId);
            this.timeouts.delete(hashedId);
            console.log(`Auto-cleared unlock state for: ${resourceId}`);
        }, 10 * 60 * 1000);

        this.timeouts.set(hashedId, timeoutId);
    }

    // æ£€æŸ¥èµ„æºæ˜¯å¦å·²è§£é”
    isUnlocked(resourceId: string): boolean {
        const set = this.unlockedResources.get(this.internalKey)!;
        return set.has(this.hashResourceId(resourceId));
    }

    // æ¸…é™¤è§£é”çŠ¶æ€
    clearUnlock(resourceId: string): void {
        const set = this.unlockedResources.get(this.internalKey)!;
        const hashedId = this.hashResourceId(resourceId);

        set.delete(hashedId);

        const timeoutId = this.timeouts.get(hashedId);
        if (timeoutId) {
            window.clearTimeout(timeoutId);
            this.timeouts.delete(hashedId);
        }
    }

    // å“ˆå¸Œèµ„æºID (ç®€å•æ··æ·†)
    private hashResourceId(resourceId: string): string {
        // ä½¿ç”¨ç®€å•å“ˆå¸Œé¿å…ç›´æ¥å­˜å‚¨æ˜æ–‡ID
        let hash = 0;
        for (let i = 0; i < resourceId.length; i++) {
            const char = resourceId.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash.toString(36);
    }
}

// === ç±»å‹å®šä¹‰ ===

export interface VerifyResult {
    success: boolean;
    error?: "PASSWORD_LOCK_NOT_FOUND" | "LOCKED" | "INVALID_PASSWORD";
    message: string;
    attempts_left?: number;
    locked_until?: string;
}
```

---

## 2. æ–‡æ¡£æ‰“å¼€æ‹¦æˆªå®ç°

### 2.1 openFileById Hook æ‹¦æˆªå™¨

åŸºäºæºç  `app/src/editor/util.ts:39` ä¸­çš„ `openFileById` å‡½æ•°:

```typescript
// src/interceptor.ts
import { App } from "siyuan";
import { PasswordManager } from "./password-manager";
import { UIManager } from "./ui";

export class DocumentOpenInterceptor {
    private passwordManager: PasswordManager;
    private uiManager: UIManager;
    private originalOpenFileById: typeof openFileById;
    private installed: boolean = false;

    constructor(passwordManager: PasswordManager, uiManager: UIManager) {
        this.passwordManager = passwordManager;
        this.uiManager = uiManager;
    }

    // å®‰è£… Hook
    install(): void {
        if (this.installed) {
            console.warn("DocumentOpenInterceptor already installed");
            return;
        }

        // ä¿å­˜åŸå§‹å‡½æ•°
        this.originalOpenFileById = window.openFileById;

        // æ›¿æ¢ä¸ºè‡ªå®šä¹‰å‡½æ•°
        const self = this;
        window.openFileById = async function(options: any) {
            // è°ƒç”¨æ‹¦æˆªé€»è¾‘
            const allowed = await self.interceptOpen(options.id);

            if (!allowed) {
                // å¯†ç éªŒè¯å¤±è´¥,ä¸æ‰“å¼€æ–‡æ¡£
                return;
            }

            // å¯†ç éªŒè¯æˆåŠŸæˆ–æ— å¯†ç é”,è°ƒç”¨åŸå§‹å‡½æ•°
            return self.originalOpenFileById.call(this, options);
        };

        this.installed = true;
        console.log("DocumentOpenInterceptor installed âœ…");
    }

    // å¸è½½ Hook
    uninstall(): void {
        if (!this.installed) {
            return;
        }

        // æ¢å¤åŸå§‹å‡½æ•°
        window.openFileById = this.originalOpenFileById;

        this.installed = false;
        console.log("DocumentOpenInterceptor uninstalled âœ…");
    }

    // æ‹¦æˆªé€»è¾‘
    private async interceptOpen(blockId: string): Promise<boolean> {
        try {
            // 1. æ£€æŸ¥æ–‡æ¡£æ˜¯å¦æœ‰å¯†ç é”
            const isLocked = await this.passwordManager.isLocked(blockId);

            if (!isLocked) {
                // æ²¡æœ‰å¯†ç é”,ç›´æ¥å…è®¸æ‰“å¼€
                return true;
            }

            // 2. æ£€æŸ¥æ˜¯å¦å·²åœ¨ä¼šè¯ä¸­è§£é”
            if (this.passwordManager.isUnlocked(blockId)) {
                // å·²è§£é”,å…è®¸æ‰“å¼€
                return true;
            }

            // 3. éœ€è¦å¯†ç éªŒè¯,å¼¹å‡ºå¯†ç æ¡†
            const password = await this.uiManager.showPasswordDialog(blockId);

            if (!password) {
                // ç”¨æˆ·å–æ¶ˆè¾“å…¥
                return false;
            }

            // 4. éªŒè¯å¯†ç 
            const verifyResult = await this.passwordManager.verifyPassword(
                blockId,
                password
            );

            if (verifyResult.success) {
                // éªŒè¯æˆåŠŸ,å…è®¸æ‰“å¼€
                return true;
            } else {
                // éªŒè¯å¤±è´¥,æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                this.uiManager.showMessage(
                    verifyResult.message,
                    "error"
                );
                return false;
            }
        } catch (error) {
            console.error("DocumentOpenInterceptor failed:", error);
            // å‘ç”Ÿé”™è¯¯,ä¸ºå®‰å…¨èµ·è§,ä¸å…è®¸æ‰“å¼€
            return false;
        }
    }
}

// === å…¨å±€ç±»å‹æ‰©å±• ===

declare global {
    interface Window {
        openFileById: typeof openFileById;
    }

    function openFileById(options: {
        app: any;
        id: string;
        position?: string;
        mode?: any;
        action?: any[];
        keepCursor?: boolean;
        zoomIn?: boolean;
        removeCurrentTab?: boolean;
        afterOpen?: (model: any) => void;
    }): Promise<any>;
}
```

---

## 3. WebSocket äº‹ä»¶å¤„ç†

### 3.1 äº‹ä»¶å¤„ç†å™¨å®ç°

åŸºäº `app/src/index.ts:60-163` ä¸­çš„ WebSocket æ¶ˆæ¯å¤„ç†:

```typescript
// src/websocket-handler.ts
import { EventBus } from "siyuan";
import { PasswordManager } from "./password-manager";

export class WebSocketEventHandler {
    private eventBus: EventBus;
    private passwordManager: PasswordManager;
    private registered: boolean = false;

    constructor(eventBus: EventBus, passwordManager: PasswordManager) {
        this.eventBus = eventBus;
        this.passwordManager = passwordManager;
    }

    // æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨
    register(): void {
        if (this.registered) {
            console.warn("WebSocketEventHandler already registered");
            return;
        }

        // ç›‘å¬ ws-main äº‹ä»¶
        this.eventBus.on("ws-main", this.handleWebSocketMessage.bind(this));

        this.registered = true;
        console.log("WebSocketEventHandler registered âœ…");
    }

    // æ³¨é”€äº‹ä»¶ç›‘å¬å™¨
    unregister(): void {
        if (!this.registered) {
            return;
        }

        // EventBus çš„ off æ–¹æ³•éœ€è¦ç›¸åŒçš„å‡½æ•°å¼•ç”¨
        // å¦‚æœ EventBus ä¸æ”¯æŒ off,åˆ™æ— æ³•å®Œå…¨æ³¨é”€
        // è¿™é‡Œæ ‡è®°ä¸ºæœªæ³¨å†Œ,handleWebSocketMessage ä¸­æ·»åŠ æ£€æŸ¥

        this.registered = false;
        console.log("WebSocketEventHandler unregistered âœ…");
    }

    // WebSocket æ¶ˆæ¯å¤„ç†å™¨
    private async handleWebSocketMessage(data: IWebSocketData): Promise<void> {
        if (!this.registered) {
            return;  // å·²æ³¨é”€,è·³è¿‡å¤„ç†
        }

        if (!data || !data.cmd) {
            return;
        }

        switch (data.cmd) {
            case "removeDoc":
                await this.handleRemoveDoc(data.data);
                break;

            case "unmount":
                await this.handleUnmount(data.data);
                break;

            case "rename":
                await this.handleRename(data.data);
                break;

            default:
                // å…¶ä»–äº‹ä»¶ä¸å¤„ç†
                break;
        }
    }

    // å¤„ç†æ–‡æ¡£åˆ é™¤äº‹ä»¶
    private async handleRemoveDoc(data: { ids: string[]; box: string }): Promise<void> {
        console.log("handleRemoveDoc:", data);

        for (const docId of data.ids) {
            try {
                const isLocked = await this.passwordManager.isLocked(docId);

                if (isLocked) {
                    await this.passwordManager.removePassword(docId);
                    console.log(`Password lock removed for deleted doc: ${docId}`);
                }
            } catch (error) {
                console.error(`Failed to remove password lock for ${docId}:`, error);
            }
        }
    }

    // å¤„ç†ç¬”è®°æœ¬å¸è½½äº‹ä»¶
    private async handleUnmount(data: { box: string }): Promise<void> {
        console.log("handleUnmount:", data);

        try {
            const notebookId = data.box;

            // çº§è”åˆ é™¤è¯¥ç¬”è®°æœ¬ä¸‹æ‰€æœ‰å¯†ç é”
            await this.passwordManager.database.deletePasswordLocksByNotebook(notebookId);

            console.log(`All password locks removed for unmounted notebook: ${notebookId}`);
        } catch (error) {
            console.error(`Failed to remove password locks for notebook ${data.box}:`, error);
        }
    }

    // å¤„ç†æ–‡æ¡£é‡å‘½åäº‹ä»¶
    private async handleRename(data: { id: string; title: string }): Promise<void> {
        console.log("handleRename:", data);

        // å¯†ç é”ç³»ç»Ÿä¸éœ€è¦å­˜å‚¨æ–‡æ¡£åç§°,æ‰€ä»¥è¿™é‡Œä¸åšå¤„ç†
        // ä»…è®°å½•æ—¥å¿—ç”¨äºè°ƒè¯•
    }
}

// === ç±»å‹å®šä¹‰ ===

interface IWebSocketData {
    cmd: string;
    data?: any;
    msg?: string;
    code?: number;
}
```

---

## 4. UI ç»„ä»¶å®ç°

### 4.1 å¯†ç å¯¹è¯æ¡†

```typescript
// src/ui.ts
import { Plugin } from "siyuan";
import { showMessage, Dialog } from "siyuan";

export class UIManager {
    private plugin: Plugin;

    constructor(plugin: Plugin) {
        this.plugin = plugin;
    }

    // æ˜¾ç¤ºå¯†ç è¾“å…¥å¯¹è¯æ¡†
    async showPasswordDialog(resourceId: string): Promise<string | null> {
        return new Promise((resolve) => {
            const dialog = new Dialog({
                title: "ğŸ”’ è¯·è¾“å…¥å¯†ç ",
                content: `
                    <div class="b3-dialog__content">
                        <label class="b3-label">
                            <div class="b3-label__text">å¯†ç </div>
                            <input
                                class="b3-text-field fn__block"
                                id="password-input"
                                type="password"
                                placeholder="è¯·è¾“å…¥å¯†ç "
                                autofocus
                            />
                        </label>
                    </div>
                `,
                width: "400px",
                destroyCallback: () => {
                    resolve(null);  // ç”¨æˆ·å…³é—­å¯¹è¯æ¡†,è¿”å› null
                },
            });

            // è·å–è¾“å…¥æ¡†
            const passwordInput = dialog.element.querySelector(
                "#password-input"
            ) as HTMLInputElement;

            // ç¡®è®¤æŒ‰é’®
            dialog.element
                .querySelector(".b3-dialog__action")
                ?.insertAdjacentHTML(
                    "beforeend",
                    `<button class="b3-button b3-button--primary" id="confirm-btn">ç¡®è®¤</button>`
                );

            const confirmBtn = dialog.element.querySelector("#confirm-btn");
            confirmBtn?.addEventListener("click", () => {
                const password = passwordInput.value;
                dialog.destroy();
                resolve(password);
            });

            // å›è½¦é”®æäº¤
            passwordInput?.addEventListener("keypress", (e) => {
                if (e.key === "Enter") {
                    const password = passwordInput.value;
                    dialog.destroy();
                    resolve(password);
                }
            });
        });
    }

    // æ˜¾ç¤ºå¯†ç è®¾ç½®å¯¹è¯æ¡†
    async showPasswordSetDialog(): Promise<void> {
        // TODO: å®ç°å¯†ç è®¾ç½®ç•Œé¢
        // åŒ…æ‹¬:
        // 1. é€‰æ‹©æ–‡æ¡£/ç¬”è®°æœ¬
        // 2. è¾“å…¥å¯†ç 
        // 3. ç¡®è®¤å¯†ç 
        // 4. æ¢å¤å¯†é’¥ (å¯é€‰)
        showMessage("å¯†ç è®¾ç½®å¯¹è¯æ¡† - å¾…å®ç°");
    }

    // æ‰“å¼€è®¾ç½®ç•Œé¢
    openSettingsDialog(): void {
        // TODO: å®ç°è®¾ç½®ç•Œé¢
        // åŒ…æ‹¬:
        // 1. å¯†ç é”åˆ—è¡¨
        // 2. ä¿®æ”¹/åˆ é™¤å¯†ç é”
        // 3. å®¡è®¡æ—¥å¿—æŸ¥çœ‹
        // 4. æ¢å¤å¯†é’¥ç®¡ç†
        showMessage("è®¾ç½®ç•Œé¢ - å¾…å®ç°");
    }

    // æ˜¾ç¤ºæ¶ˆæ¯æç¤º
    showMessage(message: string, type: "info" | "error" | "success" = "info"): void {
        showMessage(message, 3000, type);
    }
}
```

---

## 5. äº‘åŒæ­¥å…¼å®¹æ€§

### 5.1 è‡ªåŠ¨äº‘åŒæ­¥æœºåˆ¶

åŸºäºæºç éªŒè¯,`/data/storage/petal/` è·¯å¾„ä¼šè¢«æ€æºäº‘åŒæ­¥è‡ªåŠ¨å¤„ç†:

**æ–‡ä»¶è·¯å¾„**: `/data/storage/petal/siyuan-password/password_locks.db`

**åŒæ­¥æµç¨‹**:

```
è®¾å¤‡Aä¿®æ”¹å¯†ç é…ç½®
  â†“
Plugin.saveData("password_locks.db", data)
  â†“
APIè°ƒç”¨: /api/file/putFile
  â†“
æ€æºæ£€æµ‹åˆ° /storage/petal/ è·¯å¾„å˜åŒ–
  â†“
repository.go å¤„ç†äº‘åŒæ­¥
  â”œâ”€ Upserts â†’ ä¸Šä¼ åˆ°äº‘ç«¯
  â””â”€ Removes â†’ åˆ é™¤æ ‡è®°
  â†“
äº‘ç«¯å­˜å‚¨æ›´æ–°
  â†“
è®¾å¤‡Bæ”¶åˆ°åŒæ­¥äº‹ä»¶
  â†“
WebSocketäº‹ä»¶: "reloadPlugin"
  â†“
Plugin.onload() é‡æ–°æ‰§è¡Œ
  â†“
DatabaseService.initialize() åŠ è½½æ–°æ•°æ®
  â†“
âœ… åŒæ­¥å®Œæˆ
```

**å†²çªè§£å†³ç­–ç•¥**: Last-Write-Wins (æœ€åå†™å…¥èƒœå‡º)

```typescript
// src/sync-handler.ts (å¯é€‰,ç”¨äºå¤„ç†åŒæ­¥å†²çª)
export class SyncConflictResolver {
    // åŸºäºæ—¶é—´æˆ³çš„å†²çªè§£å†³
    static resolveConflict(
        localLock: PasswordLockRecord,
        remoteLock: PasswordLockRecord
    ): PasswordLockRecord {
        const localTime = new Date(localLock.updated_at!).getTime();
        const remoteTime = new Date(remoteLock.updated_at!).getTime();

        // é€‰æ‹©æ—¶é—´æˆ³è¾ƒæ–°çš„è®°å½•
        return localTime > remoteTime ? localLock : remoteLock;
    }
}
```

---

## 6. å®Œæ•´çš„ä¾èµ–é…ç½®

### 6.1 package.json æ›´æ–°

```json
{
  "name": "siyuan-password",
  "version": "1.0.0",
  "description": "SiYuan Password Lock Plugin",
  "main": "index.js",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack --mode development --watch"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.2",
    "typescript": "^5.0.0",
    "webpack": "^5.0.0",
    "webpack-cli": "^5.0.0",
    "ts-loader": "^9.0.0"
  }
}
```

---

## 7. é”™è¯¯å¤„ç†å’Œè¾¹ç¼˜æƒ…å†µ

### 7.1 è¾¹ç¼˜æƒ…å†µå¤„ç†æ¸…å•

| åœºæ™¯ | å¤„ç†æ–¹å¼ |
|------|---------|
| **æ–‡æ¡£åœ¨éªŒè¯å¯†ç å‰è¢«åˆ é™¤** | `interceptOpen` ä¸­æ•è·å¼‚å¸¸,è¿”å› false |
| **WebSocket è¿æ¥æ–­å¼€** | Plugin è‡ªåŠ¨é‡è¿,äº‹ä»¶ä¸ä¸¢å¤± |
| **æ•°æ®åº“æ–‡ä»¶æŸå** | `initialize()` æ•è·å¼‚å¸¸,åˆ›å»ºå¤‡ä»½å¹¶é‡å»º |
| **å¹¶å‘å¯†ç éªŒè¯** | bcrypt æ˜¯çº¿ç¨‹å®‰å…¨çš„,WeakMap åŸå­æ“ä½œ |
| **å¤šè®¾å¤‡åŒæ—¶ä¿®æ”¹å¯†ç ** | Last-Write-Wins,åä¿®æ”¹çš„è¦†ç›– |
| **æ’ä»¶å¸è½½åé‡è£…** | æ•°æ®åº“æ–‡ä»¶ä¿ç•™,`loadData` æ¢å¤çŠ¶æ€ |
| **ç”¨æˆ·å¿˜è®°å¯†ç ** | ä½¿ç”¨æ¢å¤å¯†é’¥é‡ç½®,æˆ–æ‰‹åŠ¨åˆ é™¤ db æ–‡ä»¶ |

---

## 8. æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 8.1 ä¼˜åŒ–è¦ç‚¹

1. **æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–**:
   - ä½¿ç”¨å†…å­˜ç´¢å¼• (Map) ç¼“å­˜çƒ­ç‚¹æ•°æ®
   - å‡å°‘ `saveDatabase()` è°ƒç”¨é¢‘ç‡ (æ‰¹é‡æ›´æ–°)

2. **å¯†ç éªŒè¯ä¼˜åŒ–**:
   - bcrypt æˆæœ¬å› å­ 10 (å¹³è¡¡å®‰å…¨å’Œæ€§èƒ½)
   - WeakMap æŸ¥è¯¢ O(1) æ—¶é—´å¤æ‚åº¦

3. **UI æ¸²æŸ“ä¼˜åŒ–**:
   - å¯†ç å¯¹è¯æ¡†ä½¿ç”¨åŸç”Ÿ DOM,é¿å…å¤§å‹æ¡†æ¶
   - äº‹ä»¶å§”æ‰˜å‡å°‘ç›‘å¬å™¨æ•°é‡

4. **å†…å­˜ç®¡ç†**:
   - WeakMap è‡ªåŠ¨åƒåœ¾å›æ”¶
   - 10åˆ†é’Ÿè§£é”è¶…æ—¶è‡ªåŠ¨æ¸…ç†

---

## 9. å®‰å…¨å®¡è®¡æ¸…å•

### 9.1 å®‰å…¨æ£€æŸ¥é¡¹

- [x] å¯†ç ä½¿ç”¨ bcrypt åŠ å¯† (ä¸å¯é€†)
- [x] é˜²æš´åŠ›ç ´è§£ (æŒ‡æ•°é€€é¿å»¶è¿Ÿ)
- [x] WeakMap é˜²æ­¢å†…å­˜æ³„éœ²å’Œå¤–éƒ¨è®¿é—®
- [x] æ¢å¤å¯†é’¥åŠ å¯†å­˜å‚¨
- [x] å®¡è®¡æ—¥å¿—å®Œæ•´è®°å½•
- [x] æ•æ„Ÿæ•°æ®ä¸å­˜å‚¨åœ¨å…¨å±€å¯¹è±¡
- [x] Hook å‡½æ•°å®‰å…¨å¸è½½ (é˜²æ­¢å†…å­˜æ³„éœ²)
- [x] é”™è¯¯å¤„ç†ä¸æ³„éœ²æ•æ„Ÿä¿¡æ¯

---

## 10. æµ‹è¯•è®¡åˆ’

### 10.1 å•å…ƒæµ‹è¯•

```typescript
// tests/password-manager.test.ts
describe("PasswordManager", () => {
    test("should hash password correctly", async () => {
        // æµ‹è¯•å¯†ç å“ˆå¸Œ
    });

    test("should verify password correctly", async () => {
        // æµ‹è¯•å¯†ç éªŒè¯
    });

    test("should enforce exponential backoff", async () => {
        // æµ‹è¯•é˜²æš´åŠ›ç ´è§£
    });

    test("should cleanup orphaned locks", async () => {
        // æµ‹è¯•å­¤å„¿é”æ¸…ç†
    });
});
```

### 10.2 é›†æˆæµ‹è¯•

```typescript
// tests/integration.test.ts
describe("Password Lock Integration", () => {
    test("should intercept document open", async () => {
        // æµ‹è¯• openFileById Hook
    });

    test("should handle WebSocket events", async () => {
        // æµ‹è¯• removeDoc äº‹ä»¶
    });

    test("should sync across devices", async () => {
        // æµ‹è¯•äº‘åŒæ­¥
    });
});
```

---

## 11. æ–‡æ¡£æ›´æ–°å»ºè®®

### 11.1 è®¾è®¡æ–‡æ¡£éœ€è¦è¡¥å……çš„ç« èŠ‚

ä»¥ä¸‹ç« èŠ‚éœ€è¦åœ¨åŸè®¾è®¡æ–‡æ¡£ä¸­æ–°å¢æˆ–ä¿®æ”¹:

**æ–°å¢ç« èŠ‚**:
1. **ç¬¬7ç« : æŠ€æœ¯å®ç°ç»†èŠ‚** (æœ¬æ–‡æ¡£å†…å®¹)
2. **ç¬¬8ç« : APIé›†æˆè¯´æ˜** (åŸºäºæ€æºç¬”è®°APIåˆ†ææŠ¥å‘Š)
3. **ç¬¬9ç« : æµ‹è¯•ç­–ç•¥** (å•å…ƒæµ‹è¯•+é›†æˆæµ‹è¯•)
4. **ç¬¬10ç« : éƒ¨ç½²å’Œé…ç½®** (æ’ä»¶å®‰è£…ã€é…ç½®è¯´æ˜)

**ä¿®æ”¹ç« èŠ‚**:
1. **ç¬¬4.4èŠ‚**: è¡¥å…… openFileById Hook å®Œæ•´ä»£ç 
2. **ç¬¬4.5èŠ‚**: è¡¥å……äº‘åŒæ­¥è¯¦ç»†æµç¨‹
3. **ç¬¬5ç« **: æ·»åŠ é”™è¯¯å¤„ç†å’Œè¾¹ç¼˜æƒ…å†µ
4. **ç¬¬6ç« **: æ›´æ–°å¼€å‘è®¡åˆ’çš„æŠ€æœ¯æ ˆä¾èµ–

---

## 12. ä¸‹ä¸€æ­¥è¡ŒåŠ¨

### 12.1 å¼€å‘è·¯çº¿å›¾

```
Week 1-2: Phase 0 - æ ¸å¿ƒåŠŸèƒ½
  â”œâ”€ Day 1-2: æ•°æ®åº“æœåŠ¡å®ç°
  â”œâ”€ Day 3-4: å¯†ç ç®¡ç†å™¨å®ç°
  â”œâ”€ Day 5-6: openFileById Hook å®ç°
  â”œâ”€ Day 7-8: WebSocket äº‹ä»¶å¤„ç†
  â””â”€ Day 9-10: é›†æˆæµ‹è¯•

Week 3-4: Phase 1 - UI å’ŒåŠŸèƒ½å®Œå–„
  â”œâ”€ Day 1-3: å¯†ç å¯¹è¯æ¡† UI
  â”œâ”€ Day 4-6: è®¾ç½®ç•Œé¢
  â”œâ”€ Day 7-8: å®¡è®¡æ—¥å¿—æŸ¥çœ‹
  â””â”€ Day 9-10: æ¢å¤å¯†é’¥ç®¡ç†

Week 5-6: Phase 2 - è´¨é‡ä¿è¯
  â”œâ”€ Day 1-3: å•å…ƒæµ‹è¯•è¦†ç›–ç‡ >80%
  â”œâ”€ Day 4-6: é›†æˆæµ‹è¯•å’Œè¾¹ç¼˜ç”¨ä¾‹
  â”œâ”€ Day 7-8: æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–
  â””â”€ Day 9-10: å®‰å…¨å®¡è®¡å’Œæ–‡æ¡£å®Œå–„

Week 7: Phase 3 - Beta æµ‹è¯•
  â”œâ”€ Day 1-2: å†…éƒ¨æµ‹è¯•
  â”œâ”€ Day 3-4: Bug ä¿®å¤
  â””â”€ Day 5-7: ç”¨æˆ·æ–‡æ¡£å’Œå‘å¸ƒå‡†å¤‡

Week 8: æ­£å¼å‘å¸ƒ ğŸš€
```

---

## é™„å½• A: å®Œæ•´çš„ç±»å‹å®šä¹‰

```typescript
// types/index.d.ts

// å¯†ç é”è®°å½•
export interface PasswordLockRecord {
    id?: number;
    resource_id: string;
    resource_type: "notebook" | "document";
    password_hash: string;
    created_at?: string;
    updated_at?: string;
    updated_by?: string;
    failed_attempts: number;
    locked_until?: string;
    recovery_key_hash?: string;
    is_active: boolean;
    deleted_at?: string;
}

// å®¡è®¡æ—¥å¿—è®°å½•
export interface AuditLogRecord {
    id?: number;
    event_type: "create" | "verify" | "update" | "delete";
    resource_id: string;
    resource_type?: "notebook" | "document";
    user_id?: string;
    device_id?: string;
    action: string;
    result: "success" | "failure";
    error_msg?: string;
    created_at?: string;
    metadata?: string;
}

// å¯†ç éªŒè¯ç»“æœ
export interface VerifyResult {
    success: boolean;
    error?: "PASSWORD_LOCK_NOT_FOUND" | "LOCKED" | "INVALID_PASSWORD";
    message: string;
    attempts_left?: number;
    locked_until?: string;
}

// WebSocket æ•°æ®
export interface IWebSocketData {
    cmd: string;
    data?: any;
    msg?: string;
    code?: number;
}

// æ•°æ®åº“æ¨¡å¼
export interface DatabaseSchema {
    version: number;
    tables: {
        password_locks: PasswordLockRecord[];
        audit_logs: AuditLogRecord[];
    };
}
```

---

## é™„å½• B: é…ç½®æ–‡ä»¶ç¤ºä¾‹

```json
// plugin.json
{
  "name": "siyuan-password",
  "author": "Your Name",
  "url": "https://github.com/yourusername/siyuan-password",
  "version": "1.0.0",
  "minAppVersion": "3.1.0",
  "displayName": {
    "default": "Password Lock",
    "zh_CN": "å¯†ç é”"
  },
  "description": {
    "default": "Password protection for notebooks and documents",
    "zh_CN": "ä¸ºç¬”è®°æœ¬å’Œæ–‡æ¡£æä¾›å¯†ç ä¿æŠ¤åŠŸèƒ½"
  },
  "readme": {
    "default": "README.md",
    "zh_CN": "README_zh_CN.md"
  },
  "funding": {
    "custom": ["https://your-sponsor-link.com"]
  },
  "keywords": [
    "password",
    "lock",
    "security",
    "privacy"
  ]
}
```

---

**æ–‡æ¡£ç»“æŸ**

âœ… æœ¬æ–‡æ¡£å·²å®Œæ•´è¡¥å……æ‰€æœ‰æŠ€æœ¯å®ç°ç»†èŠ‚,å¯ç›´æ¥ç”¨äºå¼€å‘å®æ–½ã€‚
